package app

import (
	"context"
	"github.com/gorilla/mux"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
	"wallet/config"
	"wallet/internal/infrastructure/broker/kafka"
	"wallet/internal/infrastructure/cache/redis"
	"wallet/internal/infrastructure/database/postgres"
	"wallet/internal/interface/http/v1/api"
	"wallet/internal/presenter"
	transactionRepository "wallet/internal/repository/transaction"
	walletRepository "wallet/internal/repository/wallet"
	"wallet/internal/service"
	"wallet/internal/utils/httpserver"
	"wallet/internal/utils/metrics"
	"wallet/internal/utils/pprof"

	httpSwagger "github.com/swaggo/http-swagger/v2"
	_ "wallet/docs" // docs generated by Swag CLI, you have to import it.
)

const (
	pathToAPIWallets = "/api/v1/wallets"

	shutdownTimeout = 5 * time.Second
)

func Run(cfg *config.Config) {

	ctx := context.Background()

	store, err := postgres.NewStore(ctx, cfg.Database.Convert())
	if err != nil {
		log.Fatal(err)
	}
	defer store.Close()

	cache, err := redis.New(ctx, cfg.Cache.Convert())
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := cache.Close(); err != nil {
			log.Println(err)
		}
	}()

	consumer := kafka.NewConsumer(cfg.Consumer.Convert())
	defer func() {
		if err := consumer.Close(); err != nil {
			log.Println(err)
		}
	}()

	producer, err := kafka.NewProducer(cfg.Producer.Convert())
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := producer.Close(); err != nil {
			log.Println(err)
		}
	}()

	walletRepo := walletRepository.New(cache)
	transactionRepo := transactionRepository.New(consumer, producer)

	walletService := service.New(ctx, walletRepo, transactionRepo, transactionRepo, walletRepo, store, 20)

	walletPresenter := presenter.NewPresenter(walletService)

	router := mux.NewRouter()
	router.Use(
		metrics.MW,
	)

	walletRouter := router.PathPrefix(pathToAPIWallets).Subrouter()
	walletRouter.PathPrefix("/swagger/").HandlerFunc(httpSwagger.WrapHandler)
	api.RegisterRouter(walletRouter, walletPresenter)

	profilerServer := pprof.NewPProfServer(cfg.PProf.Convert())
	go profilerServer.Run()

	metricsServer := metrics.NewMetricsServer(cfg.Metrics.Convert())
	go metricsServer.Run()

	server := httpserver.NewHTTPServer(cfg.HTTPServer.Convert(), router)
	go server.Run()

	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT, os.Interrupt)

	select {
	case sig := <-stop:
		log.Println("syscall stop", sig.String())
	case err := <-server.Notify():
		log.Println("http server notify: ", err)
	case err := <-metricsServer.Notify():
		log.Println("metrics notify: ", err)
	case err := <-profilerServer.Notify():
		log.Println("profiler notify: ", err)
	}

	shutdownCtx, shutdownCancel := context.WithTimeout(ctx, shutdownTimeout)
	defer shutdownCancel()

	if err := server.Shutdown(shutdownCtx); err != nil {
		log.Printf("http server shutdown error: %v\n", err)
	}

	if err := metricsServer.Shutdown(shutdownCtx); err != nil {
		log.Printf("metrics server shutdown error: %v\n", err)
	}

	if err := profilerServer.Shutdown(shutdownCtx); err != nil {
		log.Printf("pprof server shutdown error: %v\n", err)
	}

	log.Println("service exit")
}
